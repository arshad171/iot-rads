#include "settings/dnn.h"
// #include "src/utils/common.h"
// #include "src/camera/camera.h"

// Platform settings
// #include "settings/device.h"

// NN Layers
#include "src/dnn/layers/linear.h"
#include "src/dnn/layers/relu.h"
#include "src/dnn/losses/squared.h"

// External libraries
#include <ArduinoBLE.h>
// #include <Arduino_OV767X.h>
#include <BasicLinearAlgebra.h>

bool sendFlag = true;
bool biasFlag = false;
bool stopFlag = false;
const int BLE_NUM_WEIGHTS = 25;

typedef struct __attribute__((packed)) {
  bool syncFlag = false;
  bool biasFlag = false;
  bool stopFlag = false;
  int layerIndex;
  int rowIndex;
  int colIndex;
  float weights[BLE_NUM_WEIGHTS];
} WeightsBuffer;

int layerIndex = 1;
int rowIndex, colIndex = 0;
float avgWeightsBuffer[BLE_NUM_WEIGHTS] = { 0.0 };

// typedef struct __attribute__((packed)) {
//   int a;
//   int b;
//   float weights[25] = {-1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0};
// } Temp;

WeightsBuffer sendWeightsBuffer, receiveWeightsBuffer;
// Temp temp1, temp2;

BLEService networkService("19B10011-E8F2-537E-4F6C-D104768A1214");  // Bluetooth® Low Energy LED Service

BLECharacteristic readCharacteristic("2A36", BLERead | BLEIndicate, sizeof(sendWeightsBuffer));
BLECharacteristic writeCharacteristic("2A37", BLEWrite, sizeof(sendWeightsBuffer));

// BLECharacteristic readCharacteristic("2A36", BLERead | BLEIndicate, 1);
// BLECharacteristic writeCharacteristic("2A37", BLEWrite, 1);

// BLECharacteristic readCharacteristic("2A36", BLERead | BLEIndicate, sizeof(temp1));
// BLECharacteristic writeCharacteristic("2A37", BLEWrite, sizeof(temp1));

const float momentum = MOMENTUM;
const float learning_rate = LEARNING_RATE;
const int batch_size = BATCH_SIZE;
const int NUM_TRAINING_DATA = 100;
const int NUM_EPOCHS = 10;
const int NUM_ITERS = int(NUM_TRAINING_DATA / batch_size);

// m, n, N
const int in1 = FEATURE_DIM;
const int out1 = 10;

const int in2 = 10;
const int out2 = 2;

const int in3 = 2;
const int out3 = 10;

const int in4 = 10;
const int out4 = FEATURE_DIM;

const int inputLayersSizes[] = { in1, in2, in3, in4 };
const int outputLayersSizes[] = { out1, out2, out3, out4 };

LinearLayer<in1, out1, batch_size> lin1;
ReLULayer<out1, batch_size> rel1;

LinearLayer<in2, out2, batch_size> lin2;
ReLULayer<out2, batch_size> rel2;

LinearLayer<in3, out3, batch_size> lin3;
ReLULayer<out3, batch_size> rel3;

LinearLayer<in4, out4, batch_size> lin4;
ReLULayer<out4, batch_size> rel4;

SquaredLoss<out4, batch_size> sq;

BLA::Matrix<in1, batch_size> xBatch;

BLA::Matrix<out1, batch_size> h1;
BLA::Matrix<out2, batch_size> h2;
BLA::Matrix<out3, batch_size> h3;
BLA::Matrix<out4, batch_size> h4;

BLA::Matrix<out1, batch_size> dLdY1;
BLA::Matrix<out2, batch_size> dLdY2;
BLA::Matrix<out3, batch_size> dLdY3;
BLA::Matrix<out4, batch_size> dLdY4;

BLA::Matrix<in1, batch_size> dLdX1;
BLA::Matrix<in2, batch_size> dLdX2;
BLA::Matrix<in3, batch_size> dLdX3;
BLA::Matrix<in4, batch_size> dLdX4;

BLA::Matrix<out1, in1> dLdW1;
BLA::Matrix<out2, in2> dLdW2;
BLA::Matrix<out3, in3> dLdW3;
BLA::Matrix<out4, in4> dLdW4;

BLA::Matrix<out1, 1> dLdb1;
BLA::Matrix<out2, 1> dLdb2;
BLA::Matrix<out3, 1> dLdb3;
BLA::Matrix<out4, 1> dLdb4;

void updateXBatch(bool trainingData) {
  for (int r = 0; r < xBatch.Rows; r++) {
    for (int c = 0; c < xBatch.Cols; c++) {
      if (trainingData) {
        // get training data here, request from serial
        xBatch(r, c) = float(random(-1000, 1000) / 1000.0);
      } else {
        // get test data here, request from serial
        xBatch(r, c) = float(random(-2000, 2000) / 1000.0);
      }
    }
  }
}

/*
do one forward and backward pass.
returns the reconsturction error
*/
float iterate(BLA::Matrix<in1, batch_size> x) {
  float loss;

  // forward
  h1 = lin1.forward(x);
  h1 = rel1.forward(h1);

  h2 = lin2.forward(h1);
  h2 = rel2.forward(h2);

  h3 = lin3.forward(h2);
  h3 = rel3.forward(h3);

  h4 = lin4.forward(h3);
  h4 = rel4.forward(h4);

  // loss
  loss = sq.forward(x, h4);
  dLdY4 = sq.backward(x, h4);

  // backward & gradient descent
  dLdY4 = rel4.backward(dLdY4);
  // dLdW4 = lin4.gradWeights(dLdY4);
  // dLdb4 = lin4.gradBias(dLdY4);
  dLdW4 *= momentum;
  dLdW4 += (lin4.gradWeights(dLdY4) * (1 - momentum));
  dLdb4 *= momentum;
  dLdb4 += (lin4.gradBias(dLdY4) * (1 - momentum));
  lin4.weights -= dLdW4 * learning_rate;
  lin4.bias -= dLdb4 * learning_rate;
  dLdY3 = lin4.backward(dLdY4);

  dLdY3 = rel3.backward(dLdY3);
  // dLdW3 = lin3.gradWeights(dLdY3);
  // dLdb3 = lin3.gradBias(dLdY3);
  dLdW3 *= momentum;
  dLdW3 += (lin3.gradWeights(dLdY3) * (1 - momentum));
  dLdb3 *= momentum;
  dLdb3 += (lin3.gradBias(dLdY3) * (1 - momentum));
  lin3.weights -= dLdW3 * learning_rate;
  lin3.bias -= dLdb3 * learning_rate;
  dLdY2 = lin3.backward(dLdY3);

  dLdY2 = rel2.backward(dLdY2);
  // dLdW2 = lin2.gradWeights(dLdY2);
  // dLdb2 = lin2.gradBias(dLdY2);
  dLdW2 *= momentum;
  dLdW2 += (lin2.gradWeights(dLdY2) * (1 - momentum));
  dLdb2 *= momentum;
  dLdb2 += (lin2.gradBias(dLdY2) * (1 - momentum));
  lin2.weights -= dLdW2 * learning_rate;
  lin2.bias -= dLdb2 * learning_rate;
  dLdY1 = lin2.backward(dLdY2);

  dLdY1 = rel1.backward(dLdY1);
  // dLdW1 = lin1.gradWeights(dLdY1);
  // dLdb1 = lin1.gradBias(dLdY1);
  dLdW1 *= momentum;
  dLdW1 += (lin1.gradWeights(dLdY1) * (1 - momentum));
  dLdb1 *= momentum;
  dLdb1 += (lin1.gradBias(dLdY1) * (1 - momentum));
  lin1.weights -= dLdW1 * learning_rate;
  lin1.bias -= dLdb1 * learning_rate;

  return loss;
}

void initialize() {
  xBatch.Fill(0.0);

  h1.Fill(0.0);
  h2.Fill(0.0);
  h3.Fill(0.0);
  h4.Fill(0.0);

  dLdY1.Fill(0.0);
  dLdY2.Fill(0.0);
  dLdY3.Fill(0.0);
  dLdY4.Fill(0.0);

  dLdX1.Fill(0.0);
  dLdX2.Fill(0.0);
  dLdX3.Fill(0.0);
  dLdX4.Fill(0.0);

  dLdW1.Fill(0.0);
  dLdW2.Fill(0.0);
  dLdW3.Fill(0.0);
  dLdW4.Fill(0.0);

  dLdb1.Fill(0.0);
  dLdb2.Fill(0.0);
  dLdb3.Fill(0.0);
  dLdb4.Fill(0.0);
}

void train() {
  float loss;
  // training
  for (int epoch = 0; epoch < NUM_EPOCHS; epoch++) {
    loss = 0.0;
    for (int iter = 0; iter < NUM_ITERS; iter++) {
      updateXBatch(true);
      loss += iterate(xBatch);
    }
    loss /= NUM_ITERS;
    Serial.print("epoch: "); Serial.print(epoch); Serial.print(" loss: "); Serial.println(loss);
    // LOG_SHORT(LOG_INFO, "epoch: %d | loss: %f", epoch, loss);
  }

  // testing
  updateXBatch(true);
  loss = iterate(xBatch);
  // LOG_SHORT(LOG_INFO, "train sample: %f", loss);
  Serial.print("train sample: "); Serial.println(loss);

  updateXBatch(false);
  loss = iterate(xBatch);

  // LOG_SHORT(LOG_INFO, "test sample: %f", loss);
  Serial.print("test sample: "); Serial.println(loss);
}

void blePeripheralConnectHandler(BLEDevice central) {
  // central connected event handler
  Serial.print("Connected event, central: ");
  Serial.println(central.address());
  BLE.advertise();
}

void blePeripheralDisconnectHandler(BLEDevice central) {
  // central disconnected event handler
  Serial.print("Disconnected event, central: ");
  Serial.println(central.address());
  BLE.advertise();
  sendFlag = true;
}

void sendSyncFlag() {
  sendWeightsBuffer.syncFlag = true;
  sendWeightsBuffer.layerIndex = 1;
  sendWeightsBuffer.rowIndex = 0;
  sendWeightsBuffer.colIndex = 0;
  for (int i = 0; i < BLE_NUM_WEIGHTS; i++) {
    sendWeightsBuffer.weights[i] = 0.0;
  }
  readCharacteristic.writeValue((byte *)&sendWeightsBuffer, sizeof(sendWeightsBuffer));
  Serial.println("sent sync packet");
}


void send() {
  sendWeightsBuffer.layerIndex = layerIndex;
  sendWeightsBuffer.rowIndex = rowIndex;
  sendWeightsBuffer.colIndex = colIndex;
  sendWeightsBuffer.biasFlag = biasFlag;
  sendWeightsBuffer.stopFlag = stopFlag;

  if (!biasFlag) {
    sendWeightsBatch();
  } else {
    sendBiasBatch();
  }
}

void receive() {
  writeCharacteristic.readValue((byte *)&receiveWeightsBuffer, sizeof(receiveWeightsBuffer));

  // bool biasFlagLocal = receiveWeightsBuffer.biasFlag;
  // int layerIndexLocal = receiveWeightsBuffer.layerIndex;
  // int rowIndexLocal = receiveWeightsBuffer.rowIndex;
  // int colIndexLocal = receiveWeightsBuffer.colIndex;

  // Serial.println("---checks---");
  // Serial.print("bias flag "); Serial.println(biasFlagLocal == biasFlag);
  // Serial.print("layer index "); Serial.println(layerIndexLocal == layerIndex);
  // Serial.print("row index "); Serial.println(rowIndexLocal == rowIndex);
  // Serial.print("col index "); Serial.println(colIndexLocal == colIndex);
  // Serial.println("---checks---");

  // if ((biasFlagLocal != biasFlag) || (layerIndexLocal != layerIndex) || (rowIndexLocal != rowIndex) || (colIndexLocal != colIndex)) {
  //   Serial.println("resending packet");
  //   return;
  // }


  if (!biasFlag) {
    receiveWeightsBatch();
  } else {
    receiveBiasBatch();
  }

  layerIndex = receiveWeightsBuffer.layerIndex;
  rowIndex = receiveWeightsBuffer.rowIndex;
  colIndex = receiveWeightsBuffer.colIndex;
  biasFlag = receiveWeightsBuffer.biasFlag;
  // stopFlag = receiveWeightsBuffer.stopFlag;

  if (!biasFlag) {
    colIndex += BLE_NUM_WEIGHTS;

    if (colIndex >= inputLayersSizes[layerIndex - 1]) {
      // move on to next neuron
      rowIndex += 1;
      colIndex = 0;
    }

    if (rowIndex >= outputLayersSizes[layerIndex - 1]) {
      // move to next layer
      rowIndex = 0;
      colIndex = 0;
      layerIndex += 1;

      // switch to sending bias
      if (layerIndex >= 5) {
        layerIndex = 1;
        rowIndex = 0;
        colIndex = 0;

        biasFlag = true;
      }
    }
  } else {
    colIndex += BLE_NUM_WEIGHTS;
    if (colIndex >= outputLayersSizes[layerIndex - 1]) {
      // next layer, start at colIndex = 0
      layerIndex += 1;
      colIndex = 0;

      // swtich back to sending weights
      if (layerIndex >= 5) {
        layerIndex = 1;
        rowIndex = 0;
        colIndex = 0;

        biasFlag = false;
        stopFlag = true;
        sendFlag = true;
      }
    }
  }
}

void sendWeightsBatch() {
  sendWeightsBuffer.syncFlag = false;
  sendWeightsBuffer.biasFlag = false;

  switch (layerIndex) {
    case 1:
      lin1.copyWeightsToBuffer(rowIndex, colIndex, sendWeightsBuffer.weights, BLE_NUM_WEIGHTS);
      break;
    case 2:
      lin2.copyWeightsToBuffer(rowIndex, colIndex, sendWeightsBuffer.weights, BLE_NUM_WEIGHTS);
      break;
    case 3:
      lin3.copyWeightsToBuffer(rowIndex, colIndex, sendWeightsBuffer.weights, BLE_NUM_WEIGHTS);
      break;
    case 4:
      lin4.copyWeightsToBuffer(rowIndex, colIndex, sendWeightsBuffer.weights, BLE_NUM_WEIGHTS);
      break;
  }

  readCharacteristic.writeValue((byte *)&sendWeightsBuffer, sizeof(sendWeightsBuffer));
  Serial.println("sent");
  Serial.print("layer: ");
  Serial.println(layerIndex);
  Serial.print("row: ");
  Serial.println(rowIndex);
  Serial.print("col: ");
  Serial.println(colIndex);
  Serial.print("bias flag: ");
  Serial.println(biasFlag);
  Serial.print("stop flag: ");
  Serial.println(stopFlag);
  Serial.println("-----");
}

void receiveWeightsBatch() {
  if (receiveWeightsBuffer.biasFlag) return;


  int layerIndex = receiveWeightsBuffer.layerIndex;
  int rowIndex = receiveWeightsBuffer.rowIndex;
  int colIndex = receiveWeightsBuffer.colIndex;
  bool biasFlag = receiveWeightsBuffer.biasFlag;

  switch (layerIndex) {
    case 1:
      lin1.copyWeightsFromBuffer(rowIndex, colIndex, receiveWeightsBuffer.weights, BLE_NUM_WEIGHTS);
      break;
    case 2:
      lin2.copyWeightsFromBuffer(rowIndex, colIndex, receiveWeightsBuffer.weights, BLE_NUM_WEIGHTS);
      break;
    case 3:
      lin3.copyWeightsFromBuffer(rowIndex, colIndex, receiveWeightsBuffer.weights, BLE_NUM_WEIGHTS);
      break;
    case 4:
      lin4.copyWeightsFromBuffer(rowIndex, colIndex, receiveWeightsBuffer.weights, BLE_NUM_WEIGHTS);
      break;
  }

  Serial.println("received");
  Serial.print("layer: ");
  Serial.println(layerIndex);
  Serial.print("row: ");
  Serial.println(rowIndex);
  Serial.print("col: ");
  Serial.println(colIndex);
  Serial.print("bias flag: ");
  Serial.println(biasFlag);
  Serial.print("stop flag: ");
  Serial.println(stopFlag);
  Serial.println("-----");
}

void receiveWeightsBatchAvg() {
  writeCharacteristic.readValue((byte *)&receiveWeightsBuffer, sizeof(receiveWeightsBuffer));
  int layerIndex = receiveWeightsBuffer.layerIndex;
  int rowIndex = receiveWeightsBuffer.rowIndex;
  int colIndex = receiveWeightsBuffer.colIndex;

  lin1.copyWeightsToBuffer(rowIndex, colIndex, avgWeightsBuffer, BLE_NUM_WEIGHTS);
  for (int i = 0; i < BLE_NUM_WEIGHTS; i++) {
    receiveWeightsBuffer.weights[i] = 0.5 * (receiveWeightsBuffer.weights[i] + avgWeightsBuffer[i]);
  }

  lin1.copyWeightsFromBuffer(rowIndex, colIndex, receiveWeightsBuffer.weights, BLE_NUM_WEIGHTS);
  Serial.println("received");
  Serial.println(receiveWeightsBuffer.weights[0]);
  Serial.println(receiveWeightsBuffer.weights[BLE_NUM_WEIGHTS - 1]);
  Serial.println(rowIndex);
  Serial.println(colIndex);
}

void sendBiasBatch() {
  sendWeightsBuffer.syncFlag = false;
  sendWeightsBuffer.biasFlag = true;

  switch (layerIndex) {
    case 1:
      lin1.copyBiasToBuffer(colIndex, sendWeightsBuffer.weights, BLE_NUM_WEIGHTS);
      break;
    case 2:
      lin2.copyBiasToBuffer(colIndex, sendWeightsBuffer.weights, BLE_NUM_WEIGHTS);
      break;
    case 3:
      lin3.copyBiasToBuffer(colIndex, sendWeightsBuffer.weights, BLE_NUM_WEIGHTS);
      break;
    case 4:
      lin4.copyBiasToBuffer(colIndex, sendWeightsBuffer.weights, BLE_NUM_WEIGHTS);
      break;
  }

  readCharacteristic.writeValue((byte *)&sendWeightsBuffer, sizeof(sendWeightsBuffer));
  Serial.println("sent (bias)");
  Serial.print("layer: ");
  Serial.println(layerIndex);
  Serial.print("row: ");
  Serial.println(rowIndex);
  Serial.print("col: ");
  Serial.println(colIndex);
  Serial.print("bias flag: ");
  Serial.println(biasFlag);
  Serial.print("stop flag: ");
  Serial.println(stopFlag);
  Serial.println("-----");
}

void receiveBiasBatch() {
  if (!receiveWeightsBuffer.biasFlag) return;

  int layerIndex = receiveWeightsBuffer.layerIndex;
  int rowIndex = receiveWeightsBuffer.rowIndex;
  int colIndex = receiveWeightsBuffer.colIndex;
  bool biasFlag = receiveWeightsBuffer.biasFlag;

  switch (layerIndex) {
    case 1:
      lin1.copyBiasFromBuffer(colIndex, receiveWeightsBuffer.weights, BLE_NUM_WEIGHTS);
      break;
    case 2:
      lin2.copyBiasFromBuffer(colIndex, receiveWeightsBuffer.weights, BLE_NUM_WEIGHTS);
      break;
    case 3:
      lin3.copyBiasFromBuffer(colIndex, receiveWeightsBuffer.weights, BLE_NUM_WEIGHTS);
      break;
    case 4:
      lin4.copyBiasFromBuffer(colIndex, receiveWeightsBuffer.weights, BLE_NUM_WEIGHTS);
      break;
  }

  Serial.println("received (bias)");
  Serial.print("layer: ");
  Serial.println(layerIndex);
  Serial.print("row: ");
  Serial.println(rowIndex);
  Serial.print("col: ");
  Serial.println(colIndex);
  Serial.print("bias flag: ");
  Serial.println(biasFlag);
  Serial.print("stop flag: ");
  Serial.println(stopFlag);
  Serial.println("-----");
}


void setup() {
  // Setup the board's status indicators
  // PINMODE(LEDR, OUTPUT);
  // PINMODE(LEDG, OUTPUT);
  // PINMODE(LEDB, OUTPUT);
  // PINMODE(LED_PWR, OUTPUT);
  // DWRITE(LEDR, 1);
  // DWRITE(LEDG, 1);
  // DWRITE(LEDB, 1);
  // DWRITE(LED_PWR, 0);

  // Initialize serial port
  // SP.initialize(BAUD_RATE, 1000);

  // Setup logging
  // set_log_lvl(LOG_LEVEL);
  // toggle_logs(true);

  // Wait on the serial and notify user
  // DWRITE(LEDB, 0);
  // SP.blocking_wait(0);
  // DWRITE(LEDB, 1);

  // Greet the user and present hardware info
  // LOG_SHORT(LOG_INFO, "Railway Anomaly Detection System v%s", FW_VERSION);

  // Tell the user we completed setup
  // DWRITE(LED_PWR, 1);

  Serial.begin(9600);

  // BLE initialization
  // begin initialization
  if (!BLE.begin()) {
    Serial.println("starting Bluetooth® Low Energy module failed!");

    while (1)
      ;
  }

  // set advertised local name and service UUID:
  BLE.setLocalName("sender");
  BLE.setAdvertisedService(networkService);

  // add the characteristic to the service
  networkService.addCharacteristic(readCharacteristic);
  networkService.addCharacteristic(writeCharacteristic);

  // add service
  BLE.addService(networkService);

  BLE.setEventHandler(BLEConnected, blePeripheralConnectHandler);
  BLE.setEventHandler(BLEDisconnected, blePeripheralDisconnectHandler);

  // set the initial value for the characeristic:
  sendSyncFlag();

  // start advertising
  BLE.advertise();

  Serial.println("i am the sender...");

  // Do stuff
  initialize();
}

void loop() {
  if (!stopFlag) {
    BLE.poll();
    if (sendFlag) {
      // sendWeights();
      //sendWeightsBatch();
      sendSyncFlag();
      Serial.println("sending weights");
      // sendFlag = false;
    }

    if (writeCharacteristic.written()) {
      sendFlag = false;

      receive();
      send();

      delay(10);
    }
  } else {
    Serial.println("training...");
    train();
    // delay(5000);
    stopFlag = false;
  }

}